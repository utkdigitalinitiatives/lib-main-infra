name: Build on Dispatch

# Triggered by repository_dispatch from lib-main repository
# Event type: drupal-dev-merge (push to dev branch in lib-main)
#
# Payload (client_payload):
#   - drupal_repo: Git repository URL
#   - drupal_ref: Branch to checkout (dev)
#   - drupal_sha: Full commit SHA

on:
  repository_dispatch:
    types: [drupal-dev-merge]

concurrency:
  group: dev-merge
  cancel-in-progress: true

env:
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  TF_VAR_admin_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
  TF_VAR_db_admin_password: ${{ secrets.DB_ADMIN_PASSWORD }}
  TF_VAR_gallery_name: ${{ vars.GALLERY_NAME }}
  TF_VAR_gallery_resource_group_name: ${{ vars.GALLERY_RESOURCE_GROUP }}
  TF_VAR_subnet_id: ${{ vars.SUBNET_ID }}
  TF_VAR_location: ${{ vars.LOCATION }}
  TF_VAR_devtest_db_host: ${{ vars.DEVTEST_DB_HOST }}
  TF_VAR_devtest_storage_account: ${{ vars.DEVTEST_STORAGE_ACCOUNT }}

jobs:
  # Build image from lib-main codebase
  build-image:
    name: Build Image
    runs-on: ubuntu-latest
    outputs:
      image_version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout infrastructure code
        uses: actions/checkout@v4

      - name: Validate dispatch payload
        run: |
          echo "Event type: ${{ github.event.action }}"
          echo "Drupal repo: ${{ github.event.client_payload.drupal_repo }}"
          echo "Drupal ref: ${{ github.event.client_payload.drupal_ref }}"
          echo "Drupal SHA: ${{ github.event.client_payload.drupal_sha }}"

          if [ -z "${{ github.event.client_payload.drupal_repo }}" ]; then
            echo "::error::Missing drupal_repo in payload"
            exit 1
          fi

      - name: Generate version
        id: version
        run: |
          echo "version=0.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "Building image version: 0.0.${{ github.run_number }}"

      - name: Setup Packer
        uses: hashicorp/setup-packer@main
        with:
          version: latest

      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Get base image version
        id: base_version
        run: |
          echo "Querying Azure Shared Image Gallery for latest base image..."
          VERSION=$(az sig image-version list \
            --gallery-name ${{ vars.GALLERY_NAME }} \
            --gallery-image-definition drupal-base-rocky-linux-9 \
            --resource-group ${{ vars.GALLERY_RESOURCE_GROUP }} \
            --query "sort_by([].name, &@)[-1]" -o tsv)

          if [ -z "$VERSION" ]; then
            echo "::error::No base image found in gallery. Run base-image-build.yml first."
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using base image version: $VERSION"

      - name: Build image
        working-directory: packer
        run: |
          packer init .
          packer build \
            -force \
            -only='drupal-rocky9*' \
            -var "subscription_id=$ARM_SUBSCRIPTION_ID" \
            -var "client_id=$ARM_CLIENT_ID" \
            -var "client_secret=$ARM_CLIENT_SECRET" \
            -var "tenant_id=$ARM_TENANT_ID" \
            -var "use_azure_cli_auth=false" \
            -var "image_version=${{ steps.version.outputs.version }}" \
            -var "base_image_version=${{ steps.base_version.outputs.version }}" \
            -var "gallery_resource_group_name=${{ vars.GALLERY_RESOURCE_GROUP }}" \
            -var "gallery_name=${{ vars.GALLERY_NAME }}" \
            -var "image_name=drupal-rocky-linux-9" \
            -var "location=${{ vars.LOCATION }}" \
            -var "replication_regions=[\"${{ vars.LOCATION }}\"]" \
            -var "drupal_repo=${{ github.event.client_payload.drupal_repo }}" \
            -var "drupal_ref=${{ github.event.client_payload.drupal_ref }}" \
            .

      - name: Build Summary
        run: |
          echo "## Image Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Event Type:** ${{ github.event.action }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Drupal Repo:** ${{ github.event.client_payload.drupal_repo }}" >> $GITHUB_STEP_SUMMARY
          echo "**Drupal Ref:** ${{ github.event.client_payload.drupal_ref }}" >> $GITHUB_STEP_SUMMARY
          echo "**Drupal SHA:** ${{ github.event.client_payload.drupal_sha }}" >> $GITHUB_STEP_SUMMARY

  # Prepare Database (sync production â†’ devtest)
  prepare-database:
    name: Prepare Database
    needs: build-image
    runs-on: ubuntu-latest
    concurrency:
      group: devtest-database
      cancel-in-progress: false

    steps:
      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Start PostgreSQL if stopped
        run: |
          SERVER_NAME="drupal-devtest-psql"
          RG="lib-main-devtest-rg"

          STATE=$(az postgres flexible-server show \
            --name "$SERVER_NAME" --resource-group "$RG" \
            --query "state" -o tsv)
          echo "Current PostgreSQL state: $STATE"

          if [ "$STATE" != "Ready" ]; then
            echo "Starting PostgreSQL server..."
            az postgres flexible-server start \
              --name "$SERVER_NAME" --resource-group "$RG"

            # Wait for server to become ready
            for i in {1..60}; do
              STATE=$(az postgres flexible-server show \
                --name "$SERVER_NAME" --resource-group "$RG" \
                --query "state" -o tsv)
              if [ "$STATE" == "Ready" ]; then
                echo "PostgreSQL is ready (attempt $i)"
                break
              fi
              echo "Waiting for PostgreSQL... (attempt $i/60, state: $STATE)"
              sleep 10
            done

            if [ "$STATE" != "Ready" ]; then
              echo "::error::PostgreSQL failed to start after 10 minutes"
              exit 1
            fi
          fi

      - name: Sync production database to devtest
        env:
          PGSSLMODE: require
          PROD_HOST: drupal-production-psql.postgres.database.azure.com
          DEVTEST_HOST: ${{ vars.DEVTEST_DB_HOST }}
          DB_USER: drupaladmin
          DB_PASSWORD: ${{ secrets.DB_ADMIN_PASSWORD }}
          DB_NAME: drupal
        run: |
          # Install PostgreSQL client
          sudo apt-get update -qq
          sudo apt-get install -y -qq postgresql-client

          echo "Dumping production database..."
          PGPASSWORD="$DB_PASSWORD" pg_dump \
            -h "$PROD_HOST" -U "$DB_USER" -d "$DB_NAME" \
            --format=custom --no-owner --no-acl \
            -f /tmp/production.dump

          echo "Terminating existing connections to devtest database..."
          PGPASSWORD="$DB_PASSWORD" psql \
            -h "$DEVTEST_HOST" -U "$DB_USER" -d postgres \
            -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$DB_NAME' AND pid <> pg_backend_pid();" || true

          echo "Dropping and recreating devtest database..."
          PGPASSWORD="$DB_PASSWORD" psql \
            -h "$DEVTEST_HOST" -U "$DB_USER" -d postgres \
            -c "DROP DATABASE IF EXISTS $DB_NAME;"
          PGPASSWORD="$DB_PASSWORD" psql \
            -h "$DEVTEST_HOST" -U "$DB_USER" -d postgres \
            -c "CREATE DATABASE $DB_NAME;"

          echo "Restoring production dump to devtest..."
          PGPASSWORD="$DB_PASSWORD" pg_restore \
            -h "$DEVTEST_HOST" -U "$DB_USER" -d "$DB_NAME" \
            --no-owner --no-acl \
            /tmp/production.dump

          echo "Ensuring pg_trgm extension exists..."
          PGPASSWORD="$DB_PASSWORD" psql \
            -h "$DEVTEST_HOST" -U "$DB_USER" -d "$DB_NAME" \
            -c "CREATE EXTENSION IF NOT EXISTS pg_trgm;"

          echo "Database sync complete"
          rm -f /tmp/production.dump

  # Deploy Dev Environment
  deploy-dev:
    name: Deploy Dev
    needs: [build-image, prepare-database]
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      dev_vm_ip: ${{ steps.outputs.outputs.public_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Get devtest storage key
        run: |
          KEY=$(az storage account keys list \
            --account-name "${{ vars.DEVTEST_STORAGE_ACCOUNT }}" \
            --resource-group lib-main-devtest-rg \
            --query "[0].value" -o tsv)
          echo "::add-mask::$KEY"
          echo "TF_VAR_devtest_storage_key=$KEY" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: environments/dev
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ vars.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ vars.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=dev/terraform.tfstate"

      - name: Terraform Apply
        working-directory: environments/dev
        run: |
          terraform apply -auto-approve \
            -var="image_version=${{ needs.build-image.outputs.image_version }}"

      - name: Get Outputs
        id: outputs
        working-directory: environments/dev
        run: |
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT

      - name: Run Dev Validation Tests
        run: |
          DEV_IP="${{ steps.outputs.outputs.public_ip }}"
          echo "Testing health endpoint on $DEV_IP..."

          for i in {1..30}; do
            if curl -ksf https://${DEV_IP}/health; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Waiting for VM... (attempt $i/30)"
            sleep 10
          done

          echo "Health check failed after 30 attempts"
          exit 1

      - name: Dev Deploy Summary
        run: |
          echo "## Dev Environment Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Site URL:** https://${{ steps.outputs.outputs.public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Version:** ${{ needs.build-image.outputs.image_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Drupal SHA:** ${{ github.event.client_payload.drupal_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Waiting for manual approval. After approval, create a PR from dev to main to deploy to production." >> $GITHUB_STEP_SUMMARY

  # Dev Review Gate (human approval required)
  dev-review:
    name: Dev Review
    needs: [build-image, deploy-dev]
    runs-on: ubuntu-latest
    environment: dev-review

    steps:
      - name: Dev Review Approved
        run: |
          echo "## Dev Review Approved" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Dev environment validated. Create a PR from dev to main to deploy to production." >> $GITHUB_STEP_SUMMARY
